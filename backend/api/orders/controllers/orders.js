'use strict';


/**
 * Read the documentation (https://strapi.io/documentation/v3.x/concepts/controllers.html#core-controllers)
 * to customize this controller
 */
const axios = require('axios')
const moment = require('moment')
const CryptoJS = require('crypto-js')
const Paymentwall = require('paymentwall');

module.exports = {
  async users(ctx) {
    const {
      user
    } = ctx.state

    const entity = await strapi.query('orders').findOne({
      status: 'Pending',
      user: user.id
    })
    return entity
  },
  /*
  async update(ctx) {
    const {
      user
    } = ctx.state
    const params = ctx.params

    var entity = await strapi.query('orders').findOne({
      status: 'Pending',
      user: user.id
    })

    const totalAmount = entity.products.reduce((total, b) => {
      return total + b.product.price * b.cant
    }, 0)
    var payment = {
      amount: totalAmount,
      currency: "UYU",
      country: "UY",
      payment_method_id: "CARD",
      payment_method_flow: "DIRECT",
      payer: {
        name: ctx.request.name,
        email: user.email,
        document: '49135739',
        user_reference: user.id,
        address: {
          state: "Rio de Janeiro",
          city: "Volta Redonda",
          zip_code: "27275-595",
          street: "Servidao B-1",
          number: "1106"
        },
        ip: ctx.request.header['x-real-ip'],
        device_id: "2fg3d4gf234"
      },
      card: {
        token: ctx.request.body.token
      },
      order_id: entity.id,
    }


    const makeRequest = async (body) => {
      console.log(body)
      let xDate = moment().format();
      let xLogin = '78697db436'
      let xTransKey = 'c5fa492a49'
      let authorization = CryptoJS.HmacSHA256(xLogin + xDate + JSON.stringify(body), 'd3dba255294d31f4f98148a759576d3b3').toString(CryptoJS.enc.Hex)
      let response = await axios.post('https://sandbox.dlocal.com/payments', payment, {
        headers: {
          'X-Date': xDate,
          'X-Login': xLogin,
          'X-Trans-Key': xTransKey,
          'Authorization': 'V2-HMAC-SHA256, Signature: ' + authorization
        }
      })
      return response

    }

    try {
      var response = await makeRequest(payment)
      console.log(response)
    } catch (error) {
      console.log(error)
    }
    
    if (response.data.status=='PAID') {
      entity.status = 'Finished'
    } else {
      entity.status = 'Rejected'
    }

    await strapi.query('orders').update({
      status: 'Pending',
      user: user.id
    }, {
      status: entity.status
    })
    
    return await entity
  },
  */
  async update(ctx) {
    const {
      user
    } = ctx.state

    Paymentwall.Configure(
      Paymentwall.Base.API_GOODS,
      't_afdea10ec5808417a5e3f0e6bb57ef',
      't_fe3e1010469ebc5ce60e9c94c9996c'
    );

    var entity = await strapi.query('orders').findOne({
      status: 'Pending',
      user: user.id
    })
    const totalAmount = entity.products.reduce((total, b) => {
      return total + b.product.price * b.cant
    }, 0)

    var charge = new Paymentwall.Charge(
      totalAmount, //price
      'UYU', //currency code
      'description', //description of the product
      'brunodiharce@gmail.com', // user's email
      ctx.request.body.fingerprint, // fingerprint generated by Brick.js
      ctx.request.body.token, //one-time token,
      {
        'user_id':user.id
      }
    );
    return await new Promise((resolve, reject) => {
      charge.createCharge(async (brick_response) => {
        var status = {} 
        console.log(brick_response.isSuccessful())
        if (brick_response.isSuccessful()) {
          if (brick_response.isCaptured()) {
            status = 'Payed'
          } else if (brick_response.isUnderReview()) {
            status = 'Pending'
          }
        } else {
          status = 'Rejected'
        }

        await strapi.query('orders').update({
          status: 'Pending',
          user: user.id
        }, {
          status: status
        })

        return resolve(status)
      })
    })
  },
  async testPaymentWall(ctx) {
    const {
      user
    } = ctx.state

    Paymentwall.Configure(
      Paymentwall.Base.API_GOODS,
      't_afdea10ec5808417a5e3f0e6bb57ef',
      't_fe3e1010469ebc5ce60e9c94c9996c'
    );

    var charge = new Paymentwall.Charge(
      12, //price
      'USD', //currency code
      'description', //description of the product
      'brunodiharce@gmail.com', // user's email
      ctx.request.body.fingerprint, // fingerprint generated by Brick.js
      ctx.request.body.token, //one-time token,
      {
        'user_id':user.id
      }
    );


    return await new Promise((resolve, reject) => {
      charge.createCharge(async (brick_response) => {
        var status = {}
        if (brick_response.isSuccessful()) {
          if (brick_response.isUnderReview() == 'approved') {
            status = 'Payed'
          } else  {
            status = 'Pending'
          }
        } else {
          status = 'Rejected'
        }

        return resolve(status)
      })
    })
  }


};
